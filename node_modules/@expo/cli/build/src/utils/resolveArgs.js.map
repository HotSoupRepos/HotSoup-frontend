{"version":3,"sources":["../../../src/utils/resolveArgs.ts"],"sourcesContent":["import arg, { Spec } from 'arg';\n\nimport { replaceValue } from './array';\nimport { CommandError } from './errors';\n\n/**\n * Enables the resolution of arguments that can either be a string or a boolean.\n *\n * @param args arguments that were passed to the command.\n * @param rawMap raw map of arguments that are passed to the command.\n * @param extraArgs extra arguments and aliases that should be resolved as string or boolean.\n * @returns parsed arguments and project root.\n */\nexport async function resolveStringOrBooleanArgsAsync(\n  args: string[],\n  rawMap: arg.Spec,\n  extraArgs: arg.Spec\n) {\n  // Assert any missing arguments\n  assertUnknownArgs(\n    {\n      ...rawMap,\n      ...extraArgs,\n    },\n    args\n  );\n\n  // Collapse aliases into fully qualified arguments.\n  args = collapseAliases(extraArgs, args);\n\n  // Resolve all of the string or boolean arguments and the project root.\n  return _resolveStringOrBooleanArgs({ ...rawMap, ...extraArgs }, args);\n}\n\nexport function _resolveStringOrBooleanArgs(arg: Spec, args: string[]) {\n  // Default project root, if a custom one is defined then it will overwrite this.\n  let projectRoot: string = '.';\n  // The resolved arguments.\n  const settings: Record<string, string | boolean | undefined> = {};\n\n  // Create a list of possible arguments, this will filter out aliases.\n  const possibleArgs = Object.entries(arg)\n    .filter(([, value]) => typeof value !== 'string')\n    .map(([key]) => key);\n\n  // Loop over arguments in reverse order so we can resolve if a value belongs to a flag.\n  for (let i = args.length - 1; i > -1; i--) {\n    const value = args[i];\n    // At this point we should have converted all aliases to fully qualified arguments.\n    if (value.startsWith('--')) {\n      // If we ever find an argument then it must be a boolean because we are checking in reverse\n      // and removing arguments from the array if we find a string.\n      settings[value] = true;\n    } else {\n      // Get the previous argument in the array.\n      const nextValue = i > 0 ? args[i - 1] : null;\n      if (nextValue && possibleArgs.includes(nextValue)) {\n        settings[nextValue] = value;\n        i--;\n      } else if (\n        // If the last value is not a flag and it doesn't have a recognized flag before it (instead having a string value or nothing)\n        // then it must be the project root.\n        i ===\n        args.length - 1\n      ) {\n        projectRoot = value;\n      } else {\n        // This will asserts if two strings are passed in a row and not at the end of the line.\n        throw new CommandError('BAD_ARGS', `Unknown argument: ${value}`);\n      }\n    }\n  }\n\n  return {\n    args: settings,\n    projectRoot,\n  };\n}\n\n/** Convert all aliases to fully qualified flag names. */\nexport function collapseAliases(arg: Spec, args: string[]): string[] {\n  const aliasMap = getAliasTuples(arg);\n\n  for (const [arg, alias] of aliasMap) {\n    args = replaceValue(args, arg, alias);\n  }\n\n  // Assert if there are duplicate flags after we collapse the aliases.\n  assertDuplicateArgs(args, aliasMap);\n  return args;\n}\n\n/** Assert that the spec has unknown arguments. */\nexport function assertUnknownArgs(arg: Spec, args: string[]) {\n  const allowedArgs = Object.keys(arg);\n  const unknownArgs = args.filter((arg) => !allowedArgs.includes(arg) && arg.startsWith('-'));\n  if (unknownArgs.length > 0) {\n    throw new CommandError(`Unknown arguments: ${unknownArgs.join(', ')}`);\n  }\n}\n\nfunction getAliasTuples(arg: Spec): [string, string][] {\n  return Object.entries(arg).filter(([, value]) => typeof value === 'string') as [string, string][];\n}\n\n/** Asserts that a duplicate flag has been used, this naively throws without knowing if an alias or flag were used as the duplicate. */\nexport function assertDuplicateArgs(args: string[], argNameAliasTuple: [string, string][]) {\n  for (const [argName, argNameAlias] of argNameAliasTuple) {\n    if (args.filter((a) => [argName, argNameAlias].includes(a)).length > 1) {\n      throw new CommandError(\n        'BAD_ARGS',\n        `Can only provide one instance of ${argName} or ${argNameAlias}`\n      );\n    }\n  }\n}\n"],"names":["resolveStringOrBooleanArgsAsync","_resolveStringOrBooleanArgs","collapseAliases","assertUnknownArgs","assertDuplicateArgs","args","rawMap","extraArgs","arg","projectRoot","settings","possibleArgs","Object","entries","filter","value","map","key","i","length","startsWith","nextValue","includes","CommandError","aliasMap","getAliasTuples","alias","replaceValue","allowedArgs","keys","unknownArgs","join","argNameAliasTuple","argName","argNameAlias","a"],"mappings":"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"}