{"version":3,"sources":["../../src/ios/BuildScheme.ts"],"names":["getSchemesFromXcodeproj","projectRoot","getRunnableSchemesFromXcodeproj","configuration","project","map","target","osType","type","productType","TargetType","WATCH","startsWith","APPLICATION","xcConfigurationList","hash","objects","XCConfigurationList","buildConfigurationList","buildConfiguration","buildConfigurations","find","value","comment","xcBuildConfiguration","XCBuildConfiguration","buildSdkRoot","buildSettings","SDKROOT","name","readSchemeAsync","scheme","allSchemePaths","re","RegExp","schemePath","i","exec","path","Error","getApplicationTargetNameForSchemeAsync","schemeXML","buildActionEntry","Scheme","BuildAction","BuildActionEntries","BuildActionEntry","targetName","length","getBlueprintName","entry","BuildableReference","BuildableName","endsWith","getArchiveBuildConfigurationForSchemeAsync","ArchiveAction","BlueprintName"],"mappings":";;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AA0BO,SAASA,uBAAT,CAAiCC,WAAjC,EAAgE;AACrE,SAAO,8BAAgBA,WAAhB,CAAP;AACD;;AAEM,SAASC,+BAAT,CACLD,WADK,EAEL;AAAEE,EAAAA,aAAa,GAAG;AAAlB,IAAuE,EAFlE,EAG6C;AAClD,QAAMC,OAAO,GAAG,6BAAWH,WAAX,CAAhB;AAEA,SAAO,mCAAoBG,OAApB,EAA6BC,GAA7B,CAAiC,CAAC,GAAGC,MAAH,CAAD,KAAgB;AACtD,QAAIC,MAAM,GAAG,KAAb;AACA,UAAMC,IAAI,GAAG,0BAAQF,MAAM,CAACG,WAAf,CAAb;;AAEA,QAAID,IAAI,KAAKE,qBAAWC,KAAxB,EAA+B;AAC7BJ,MAAAA,MAAM,GAAG,SAAT;AACD,KAFD,MAEO,KACL;AACA;AACA;AACAC,IAAAA,IAAI,CAACI,UAAL,CAAgBF,qBAAWG,WAA3B,CAJK,EAKL;AACA;AACA,YAAMC,mBAAmB,GACvBV,OAAO,CAACW,IAAR,CAAaX,OAAb,CAAqBY,OAArB,CAA6BC,mBAA7B,CAAiDX,MAAM,CAACY,sBAAxD,CADF;;AAGA,UAAIJ,mBAAJ,EAAyB;AACvB,cAAMK,kBAAkB,GACtBL,mBAAmB,CAACM,mBAApB,CAAwCC,IAAxC,CACGC,KAAD,IAA+CA,KAAK,CAACC,OAAN,KAAkBpB,aADnE,KAEKW,mBAAmB,CAACM,mBAApB,CAAwC,CAAxC,CAHP;;AAIA,YAAID,kBAAJ,aAAIA,kBAAJ,eAAIA,kBAAkB,CAAEG,KAAxB,EAA+B;AAAA;;AAC7B,gBAAME,oBAAoB,4BACxBpB,OAAO,CAACW,IAAR,CAAaX,OAAb,CAAqBY,OAArB,CAA6BS,oBADL,0DACxB,sBAAoDN,kBAAkB,CAACG,KAAvE,CADF;AAGA,gBAAMI,YAAY,GAAGF,oBAAoB,CAACG,aAArB,CAAmCC,OAAxD;;AACA,cACEF,YAAY,KAAK,WAAjB,IACA,4BAA4BF,oBAAoB,CAACG,aAFnD,EAGE;AACA;AACApB,YAAAA,MAAM,GAAG,MAAT;AACD,WAND,MAMO,IAAImB,YAAY,KAAK,UAArB,EAAiC;AACtCnB,YAAAA,MAAM,GAAG,KAAT;AACD;AACF;AACF;AACF;;AAED,WAAO;AACLsB,MAAAA,IAAI,EAAE,0BAAQvB,MAAM,CAACuB,IAAf,CADD;AAELtB,MAAAA,MAFK;AAGLC,MAAAA,IAAI,EAAE,0BAAQF,MAAM,CAACG,WAAf;AAHD,KAAP;AAKD,GA5CM,CAAP;AA6CD;;AAED,eAAeqB,eAAf,CACE7B,WADF,EAEE8B,MAFF,EAGkC;AAChC,QAAMC,cAAc,GAAG,8BAAgB/B,WAAhB,CAAvB;AACA,QAAMgC,EAAE,GAAG,IAAIC,MAAJ,CAAY,IAAGH,MAAO,WAAtB,EAAkC,GAAlC,CAAX;AACA,QAAMI,UAAU,GAAGH,cAAc,CAACX,IAAf,CAAoBe,CAAC,IAAIH,EAAE,CAACI,IAAH,CAAQD,CAAR,CAAzB,CAAnB;;AACA,MAAID,UAAJ,EAAgB;AACd,WAAS,MAAM,yBAAa;AAAEG,MAAAA,IAAI,EAAEH;AAAR,KAAb,CAAf;AACD,GAFD,MAEO;AACL,UAAM,IAAII,KAAJ,CAAW,WAAUR,MAAO,mDAA5B,CAAN;AACD;AACF;;AAEM,eAAeS,sCAAf,CACLvC,WADK,EAEL8B,MAFK,EAGY;AAAA;;AACjB,QAAMU,SAAS,GAAG,MAAMX,eAAe,CAAC7B,WAAD,EAAc8B,MAAd,CAAvC;AACA,QAAMW,gBAAgB,GACpBD,SADoB,aACpBA,SADoB,4CACpBA,SAAS,CAAEE,MADS,+EACpB,kBAAmBC,WADC,oFACpB,sBAAiC,CAAjC,CADoB,qFACpB,uBAAqCC,kBADjB,qFACpB,uBAA0D,CAA1D,CADoB,2DACpB,uBAA8DC,gBADhE;AAEA,QAAMC,UAAU,GACd,CAAAL,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,YAAAA,gBAAgB,CAAEM,MAAlB,MAA6B,CAA7B,GACIC,gBAAgB,CAACP,gBAAgB,CAAC,CAAD,CAAjB,CADpB,GAEIO,gBAAgB,CACdP,gBADc,aACdA,gBADc,uBACdA,gBAAgB,CAAErB,IAAlB,CAAuB6B,KAAK,IAAI;AAAA;;AAC9B,oCAAOA,KAAK,CAACC,kBAAb,oFAAO,sBAA2B,CAA3B,CAAP,qFAAO,uBAAgC,GAAhC,CAAP,qFAAO,uBAAsCC,aAA7C,2DAAO,uBAAqDC,QAArD,CAA8D,MAA9D,CAAP;AACD,GAFD,CADc,CAHtB;;AAQA,MAAI,CAACN,UAAL,EAAiB;AACf,UAAM,IAAIR,KAAJ,CAAW,GAAER,MAAO,iCAApB,CAAN;AACD;;AACD,SAAOgB,UAAP;AACD;;AAEM,eAAeO,0CAAf,CACLrD,WADK,EAEL8B,MAFK,EAGY;AAAA;;AACjB,QAAMU,SAAS,GAAG,MAAMX,eAAe,CAAC7B,WAAD,EAAc8B,MAAd,CAAvC;AACA,QAAMZ,kBAAkB,GAAGsB,SAAH,aAAGA,SAAH,6CAAGA,SAAS,CAAEE,MAAd,gFAAG,mBAAmBY,aAAtB,oFAAG,sBAAmC,CAAnC,CAAH,qFAAG,uBAAwC,GAAxC,CAAH,2DAAG,uBAA8CpC,kBAAzE;;AACA,MAAI,CAACA,kBAAL,EAAyB;AACvB,UAAM,IAAIoB,KAAJ,CAAW,GAAER,MAAO,iCAApB,CAAN;AACD;;AACD,SAAOZ,kBAAP;AACD;;AAED,SAAS8B,gBAAT,CAA0BC,KAA1B,EAA4E;AAAA;;AAC1E,SAAOA,KAAP,aAAOA,KAAP,iDAAOA,KAAK,CAAEC,kBAAd,qFAAO,uBAA4B,CAA5B,CAAP,qFAAO,uBAAiC,GAAjC,CAAP,2DAAO,uBAAuCK,aAA9C;AACD","sourcesContent":["import { readXMLAsync } from '../utils/XML';\nimport { findSchemeNames, findSchemePaths } from './Paths';\nimport { findSignableTargets, TargetType } from './Target';\nimport { getPbxproj, unquote } from './utils/Xcodeproj';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: BuildActionEntryType[];\n      }[];\n    }[];\n    ArchiveAction?: {\n      $?: {\n        buildConfiguration?: string;\n      };\n    }[];\n  };\n}\n\ninterface BuildActionEntryType {\n  BuildableReference?: {\n    $?: {\n      BlueprintName?: string;\n      BuildableName?: string;\n    };\n  }[];\n}\n\nexport function getSchemesFromXcodeproj(projectRoot: string): string[] {\n  return findSchemeNames(projectRoot);\n}\n\nexport function getRunnableSchemesFromXcodeproj(\n  projectRoot: string,\n  { configuration = 'Debug' }: { configuration?: 'Debug' | 'Release' } = {}\n): { name: string; osType: string; type: string }[] {\n  const project = getPbxproj(projectRoot);\n\n  return findSignableTargets(project).map(([, target]) => {\n    let osType = 'iOS';\n    const type = unquote(target.productType);\n\n    if (type === TargetType.WATCH) {\n      osType = 'watchOS';\n    } else if (\n      // (apps) com.apple.product-type.application\n      // (app clips) com.apple.product-type.application.on-demand-install-capable\n      // NOTE(EvanBacon): This matches against `watchOS` as well so we check for watch first.\n      type.startsWith(TargetType.APPLICATION)\n    ) {\n      // Attempt to resolve the platform SDK for each target so we can filter devices.\n      const xcConfigurationList =\n        project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];\n\n      if (xcConfigurationList) {\n        const buildConfiguration =\n          xcConfigurationList.buildConfigurations.find(\n            (value: { comment: string; value: string }) => value.comment === configuration\n          ) || xcConfigurationList.buildConfigurations[0];\n        if (buildConfiguration?.value) {\n          const xcBuildConfiguration =\n            project.hash.project.objects.XCBuildConfiguration?.[buildConfiguration.value];\n\n          const buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;\n          if (\n            buildSdkRoot === 'appletvos' ||\n            'TVOS_DEPLOYMENT_TARGET' in xcBuildConfiguration.buildSettings\n          ) {\n            // Is a TV app...\n            osType = 'tvOS';\n          } else if (buildSdkRoot === 'iphoneos') {\n            osType = 'iOS';\n          }\n        }\n      }\n    }\n\n    return {\n      name: unquote(target.name),\n      osType,\n      type: unquote(target.productType),\n    };\n  });\n}\n\nasync function readSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<SchemeXML | undefined> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`, 'i');\n  const schemePath = allSchemePaths.find(i => re.exec(i));\n  if (schemePath) {\n    return ((await readXMLAsync({ path: schemePath })) as unknown) as SchemeXML | undefined;\n  } else {\n    throw new Error(`scheme '${scheme}' does not exist, make sure it's marked as shared`);\n  }\n}\n\nexport async function getApplicationTargetNameForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildActionEntry =\n    schemeXML?.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;\n  const targetName =\n    buildActionEntry?.length === 1\n      ? getBlueprintName(buildActionEntry[0])\n      : getBlueprintName(\n          buildActionEntry?.find(entry => {\n            return entry.BuildableReference?.[0]?.['$']?.BuildableName?.endsWith('.app');\n          })\n        );\n  if (!targetName) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return targetName;\n}\n\nexport async function getArchiveBuildConfigurationForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildConfiguration = schemeXML?.Scheme?.ArchiveAction?.[0]?.['$']?.buildConfiguration;\n  if (!buildConfiguration) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return buildConfiguration;\n}\n\nfunction getBlueprintName(entry?: BuildActionEntryType): string | undefined {\n  return entry?.BuildableReference?.[0]?.['$']?.BlueprintName;\n}\n"],"file":"BuildScheme.js"}